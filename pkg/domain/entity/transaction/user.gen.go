// Code generated by protoc-gen-all. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package transaction

import (
	"fmt"
	"strings"
	"time"

	"github.com/xhayamix/proto-gen-spanner/pkg/domain/constant"
	"github.com/xhayamix/proto-gen-spanner/pkg/domain/dto/column"
)

const (
	UserTableName    = "User"
	UserComment      = "ユーザー"
	UserInsertTiming = "新規ユーザー作成時"
)

// ユーザー
type User struct {
	// ユーザーID
	UserID string `json:"UserID,omitempty"`
	// サーバー内用ユーザーID
	ServerUserID string `json:"ServerUserID,omitempty"`
	// 公開ユーザーID
	PublicUserID string `json:"PublicUserID,omitempty"`
	// 作成日時
	CreatedTime time.Time `json:"CreatedTime,omitempty"`
	// 更新日時
	UpdatedTime time.Time `json:"UpdatedTime,omitempty"`
}

func (e *User) GetPK() *UserPK {
	return &UserPK{
		UserID: e.UserID,
	}
}

func (e *User) GetVals() []interface{} {
	return []interface{}{
		e.UserID,
		e.ServerUserID,
		e.PublicUserID,
		e.CreatedTime,
		e.UpdatedTime,
	}
}

func (e *User) ToKeyValue() map[string]interface{} {
	return map[string]interface{}{
		"UserID":       e.UserID,
		"ServerUserID": e.ServerUserID,
		"PublicUserID": e.PublicUserID,
		"CreatedTime":  e.CreatedTime,
		"UpdatedTime":  e.UpdatedTime,
	}
}

func (e *User) GetTypeMap() map[string]string {
	return map[string]string{
		"UserID":       "string",
		"ServerUserID": "string",
		"PublicUserID": "string",
		"CreatedTime":  "time.Time",
		"UpdatedTime":  "time.Time",
	}
}

func (e *User) SetKeyValue(columns []string, entity []interface{}) []string {
	errs := make([]string, 0, len(columns))
	for index, column := range columns {
		if len(entity) <= index {
			break
		}
		value := entity[index]
		switch column {
		case "UserID":
			var ok bool
			e.UserID, ok = value.(string)
			if !ok {
				errs = append(errs, fmt.Sprintf("UserID: string parsing %#v: invalid syntax.", value))
			}
		case "ServerUserID":
			var ok bool
			e.ServerUserID, ok = value.(string)
			if !ok {
				errs = append(errs, fmt.Sprintf("ServerUserID: string parsing %#v: invalid syntax.", value))
			}
		case "PublicUserID":
			var ok bool
			e.PublicUserID, ok = value.(string)
			if !ok {
				errs = append(errs, fmt.Sprintf("PublicUserID: string parsing %#v: invalid syntax.", value))
			}
		case "CreatedTime":
			var v time.Time
			var err error
			valueStr, ok := value.(string)
			if ok {
				switch {
				case constant.NormalDatetimeRegExp.MatchString(valueStr):
					v, err = time.ParseInLocation("2006/01/02 15:04:05", valueStr, time.Local)
				case constant.HyphenDatetimeRegExp.MatchString(valueStr):
					v, err = time.ParseInLocation("2006-01-02 15:04:05", valueStr, time.Local)
				case valueStr == "":
				default:
					v, err = time.Parse(time.RFC3339, valueStr)
				}
				if err != nil {
					errs = append(errs, fmt.Sprintf("CreatedTime: time.Time parsing %#v: invalid syntax.", valueStr))
				} else {
					e.CreatedTime = v
				}
			} else {
				errs = append(errs, fmt.Sprintf("CreatedTime: time.Time parsing %#v: invalid syntax.", value))
			}
		case "UpdatedTime":
			var v time.Time
			var err error
			valueStr, ok := value.(string)
			if ok {
				switch {
				case constant.NormalDatetimeRegExp.MatchString(valueStr):
					v, err = time.ParseInLocation("2006/01/02 15:04:05", valueStr, time.Local)
				case constant.HyphenDatetimeRegExp.MatchString(valueStr):
					v, err = time.ParseInLocation("2006-01-02 15:04:05", valueStr, time.Local)
				case valueStr == "":
				default:
					v, err = time.Parse(time.RFC3339, valueStr)
				}
				if err != nil {
					errs = append(errs, fmt.Sprintf("UpdatedTime: time.Time parsing %#v: invalid syntax.", valueStr))
				} else {
					e.UpdatedTime = v
				}
			} else {
				errs = append(errs, fmt.Sprintf("UpdatedTime: time.Time parsing %#v: invalid syntax.", value))
			}
		}
	}
	return errs
}

// ShallowCopy CreatedTime, UpdatedTime 以外をShallowCopy
func (e *User) ShallowCopy() *User {
	return &User{
		UserID:       e.UserID,
		ServerUserID: e.ServerUserID,
		PublicUserID: e.PublicUserID,
	}
}

// DeepCopy CreatedTime, UpdatedTime 以外をDeepCopy
func (e *User) DeepCopy() *User {
	return &User{
		UserID:       e.UserID,
		ServerUserID: e.ServerUserID,
		PublicUserID: e.PublicUserID,
	}
}

// FullDeepCopy 全フィールドをDeepCopy
func (e *User) FullDeepCopy() *User {
	return &User{
		UserID:       e.UserID,
		ServerUserID: e.ServerUserID,
		PublicUserID: e.PublicUserID,
		CreatedTime:  e.CreatedTime,
		UpdatedTime:  e.UpdatedTime,
	}
}

// Reset PK, CreatedTime, UpdatedTime 以外を初期化
func (e *User) Reset() {
	e.ServerUserID = ""
	e.PublicUserID = ""
}

func (e *User) GetUserID() string {
	return e.UserID
}

type UserSlice []*User

func (s UserSlice) GetPKs() UserPKs {
	pks := make(UserPKs, 0, len(s))
	for _, e := range s {
		pks = append(pks, e.GetPK())
	}
	return pks
}

func (s UserSlice) Len() int {
	return len(s)
}

func (s UserSlice) EachRecord(iterator func(Entity) bool) {
	for _, e := range s {
		if !iterator(e) {
			break
		}
	}
}

type UserPK struct {
	UserID string
}

func (e *UserPK) ToKeyValue() map[string]interface{} {
	return map[string]interface{}{
		"UserID": e.UserID,
	}
}

func (e *UserPK) Generate() []interface{} {
	return []interface{}{
		e.UserID,
	}
}

func (e *UserPK) Key() string {
	return strings.Join([]string{
		e.UserID,
	}, "$")
}

func (e *UserPK) String() string {
	str := strings.Join([]string{
		"UserID: " + `"` + e.UserID + `"`,
	}, ", ")
	return "{" + str + "}"
}

func (e *UserPK) ToEntity() *User {
	return &User{
		UserID: e.UserID,
	}
}

func (e *UserPK) GetUserID() string {
	return e.UserID
}

type UserPKs []*UserPK

func (pks UserPKs) String() string {
	switch len(pks) {
	case 0:
		return "[]"
	case 1:
		return "[" + pks[0].String() + "]"
	}

	n := len(pks) + 1 // 前後の[]とセパレータの空文字分の長さを初期値に
	strs := make([]string, 0, len(pks))
	for _, pk := range pks {
		str := pk.String()
		n += len(str)
		strs = append(strs, str)
	}

	var b strings.Builder
	b.Grow(n)
	b.WriteString("[")
	b.WriteString(strs[0])
	for _, str := range strs[1:] {
		b.WriteString(" ")
		b.WriteString(str)
	}
	b.WriteString("]")
	return b.String()
}

var UserColumns = column.Columns{
	{
		Name:         "UserID",
		Type:         "string",
		DatabaseType: "STRING(MAX)",
		PK:           true,
		Nullable:     false,
		Comment:      "ユーザーID",
	},
	{
		Name:         "ServerUserID",
		Type:         "string",
		DatabaseType: "STRING(MAX)",
		PK:           false,
		Nullable:     false,
		Comment:      "サーバー内用ユーザーID",
	},
	{
		Name:         "PublicUserID",
		Type:         "string",
		DatabaseType: "STRING(MAX)",
		PK:           false,
		Nullable:     false,
		Comment:      "公開ユーザーID",
	},
	{
		Name:         "CreatedTime",
		Type:         "time.Time",
		DatabaseType: "TIMESTAMP",
		PK:           false,
		Nullable:     false,
		Comment:      "作成日時",
	},
	{
		Name:         "UpdatedTime",
		Type:         "time.Time",
		DatabaseType: "TIMESTAMP",
		PK:           false,
		Nullable:     false,
		Comment:      "更新日時",
	},
}

var UserColumnNames = struct {
	UserID       string
	ServerUserID string
	PublicUserID string
	CreatedTime  string
	UpdatedTime  string
}{
	UserID:       "UserID",
	ServerUserID: "ServerUserID",
	PublicUserID: "PublicUserID",
	CreatedTime:  "CreatedTime",
	UpdatedTime:  "UpdatedTime",
}

var UserColumnNameSlice = []string{
	UserColumnNames.UserID,
	UserColumnNames.ServerUserID,
	UserColumnNames.PublicUserID,
	UserColumnNames.CreatedTime,
	UserColumnNames.UpdatedTime,
}
